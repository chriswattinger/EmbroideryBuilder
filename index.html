<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Embroidery Word Builder</title>
    
    <!-- 1. Styles -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- 2. React & Libraries -->
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
    
    <!-- 3. Icons: Use vanilla Lucide -->
    <script src="https://unpkg.com/lucide@latest"></script>

    <style>
        ::-webkit-scrollbar { width: 8px; height: 8px; }
        ::-webkit-scrollbar-track { background: #f1f1f1; }
        ::-webkit-scrollbar-thumb { background: #cbd5e1; border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: #94a3b8; }
        .drag-active { background-color: #eff6ff; border-color: #6366f1; }
    </style>
</head>
<body class="bg-slate-50 text-slate-900 font-sans antialiased">
    <div id="root"></div>

    <!-- 4. Application Logic -->
    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        // --- ICON WRAPPER ---
        // Wraps vanilla Lucide icons for React usage
        const Icon = ({ name, size = 24, className = "", ...props }) => {
            const [svgHtml, setSvgHtml] = useState('');

            useEffect(() => {
                if (window.lucide && window.lucide.icons[name]) {
                    const svg = window.lucide.icons[name].toSvg({
                        width: size,
                        height: size,
                        class: className,
                        ...props
                    });
                    setSvgHtml(svg);
                }
            }, [name, size, className, props]);

            if (!svgHtml) return null;
            return <span dangerouslySetInnerHTML={{ __html: svgHtml }} className="inline-flex items-center justify-center" />;
        };

        // Define icons used in the app
        const Download = (p) => <Icon name="Download" {...p} />;
        const Upload = (p) => <Icon name="Upload" {...p} />;
        const Trash2 = (p) => <Icon name="Trash2" {...p} />;
        const Plus = (p) => <Icon name="Plus" {...p} />;
        const Info = (p) => <Icon name="Info" {...p} />;
        const Scissors = (p) => <Icon name="Scissors" {...p} />;
        const Loader2 = (p) => <Icon name="Loader2" {...p} className={`animate-spin ${p.className || ''}`} />;
        const FolderOpen = (p) => <Icon name="FolderOpen" {...p} />;
        const Database = (p) => <Icon name="Database" {...p} />;
        const Save = (p) => <Icon name="Save" {...p} />;


        // --- CONSTANTS & TYPES ---
        const NORMAL = 0, JUMP = 1, TRIM = 2, STOP = 4, END = 8;
        const DB_NAME = 'EmbroideryFontDB';
        const STORE_NAME = 'fonts';
        const DB_VERSION = 1;

        // --- UTILS: INDEXED DB ---
        const dbApi = {
            open: () => {
                return new Promise((resolve, reject) => {
                    const request = indexedDB.open(DB_NAME, DB_VERSION);
                    request.onerror = () => reject("DB Error");
                    request.onupgradeneeded = (event) => {
                        const db = event.target.result;
                        if (!db.objectStoreNames.contains(STORE_NAME)) {
                            db.createObjectStore(STORE_NAME, { keyPath: 'id' });
                        }
                    };
                    request.onsuccess = (event) => resolve(event.target.result);
                });
            },
            saveFonts: async (fontMap) => {
                const db = await dbApi.open();
                return new Promise((resolve, reject) => {
                    const transaction = db.transaction([STORE_NAME], 'readwrite');
                    const store = transaction.objectStore(STORE_NAME);
                    
                    // Store individual files with composite ID
                    let count = 0;
                    Object.entries(fontMap).forEach(([fontName, files]) => {
                        files.forEach(file => {
                            store.put({
                                id: `${fontName}_${file.name}`,
                                fontName: fontName,
                                fileName: file.name,
                                blob: file.blob
                            });
                            count++;
                        });
                    });

                    transaction.oncomplete = () => resolve(count);
                    transaction.onerror = (e) => reject("Save failed: " + e.target.error);
                });
            },
            getAllFonts: async () => {
                const db = await dbApi.open();
                return new Promise((resolve, reject) => {
                    const transaction = db.transaction([STORE_NAME], 'readonly');
                    const store = transaction.objectStore(STORE_NAME);
                    const request = store.getAll();

                    request.onsuccess = () => {
                        const result = {};
                        if (request.result.length === 0) {
                            resolve(null);
                            return;
                        }
                        request.result.forEach(item => {
                            if (!result[item.fontName]) result[item.fontName] = [];
                            result[item.fontName].push({ name: item.fileName, blob: item.blob });
                        });
                        resolve(result);
                    };
                    request.onerror = () => reject("Load failed");
                });
            },
            clear: async () => {
                const db = await dbApi.open();
                return new Promise((resolve, reject) => {
                     const transaction = db.transaction([STORE_NAME], 'readwrite');
                     const store = transaction.objectStore(STORE_NAME);
                     store.clear();
                     transaction.oncomplete = () => resolve();
                     transaction.onerror = () => reject("Clear failed");
                });
            }
        };
        
        // --- UTILS: PES PARSER ---
        const PesParser = {
            decode: (data) => {
                let idx = 0;
                const view = new DataView(data.buffer);
                const magic = String.fromCharCode(...data.slice(0, 4));
                if (magic !== '#PES') throw new Error('Invalid PES header');
                
                const pecOffset = view.getUint32(8, true);
                const numColors = view.getUint8(pecOffset + 48) + 1;
                const stitchStart = pecOffset + 532 + 2268 + numColors;
                
                idx = stitchStart;
                const stitches = [];
                let x = 0, y = 0;
                
                const readDelta = () => {
                   let b = data[idx++];
                   if (b === 0xFF && data[idx] === 0x00) return null;
                   if (b === 0xFE && data[idx] === 0xB0) return null;
                   if (b & 0x80) {
                       let next = data[idx++];
                       let val = ((b & 0x0F) << 8) | next;
                       if (b & 0x20) val = -val;
                       return val;
                   }
                   return b > 63 ? b - 128 : b;
                };

                while (idx < data.length) {
                    if (data[idx] === 0xFF && data[idx+1] === 0x00) {
                        stitches.push({ x, y, flags: END }); break;
                    }
                    if (data[idx] === 0xFE && data[idx+1] === 0xB0) {
                        idx += 3; // FE B0 Index
                        stitches.push({ x, y, flags: STOP }); continue;
                    }
                    
                    let dx = readDelta();
                    if (dx === null) continue;
                    let dy = readDelta();
                    if (dy === null) continue;
                    
                    x += dx; y += dy;
                    stitches.push({ x, y, flags: NORMAL });
                }

                let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
                stitches.forEach(s => {
                    if (s.x < minX) minX = s.x; if (s.x > maxX) maxX = s.x;
                    if (s.y < minY) minY = s.y; if (s.y > maxY) maxY = s.y;
                });

                return { stitches, width: maxX - minX, height: maxY - minY, minX, minY, maxX, maxY };
            },

            encode: (pattern) => {
                const stitchBytes = [];
                let lastX = 0, lastY = 0;

                const encodeDelta = (val) => {
                    if (val >= -64 && val <= 63) return [val < 0 ? val + 128 : val];
                    const abs = Math.abs(val);
                    let b1 = 0x80 | ((abs >> 8) & 0x0F);
                    if (val < 0) b1 |= 0x20;
                    return [b1, abs & 0xFF];
                };

                pattern.stitches.forEach(s => {
                    if (s.flags === END) { stitchBytes.push(0xFF, 0x00); return; }
                    if (s.flags === STOP) { stitchBytes.push(0xFE, 0xB0, 0x01); return; }
                    
                    let dx = s.x - lastX;
                    let dy = s.y - lastY;
                    stitchBytes.push(...encodeDelta(dx), ...encodeDelta(dy));
                    lastX = s.x; lastY = s.y;
                });
                
                if (stitchBytes[stitchBytes.length - 2] !== 0xFF) stitchBytes.push(0xFF, 0x00);

                const header = new Uint8Array(512);
                const magic = "#PES0001";
                for(let i=0; i<magic.length; i++) header[i] = magic.charCodeAt(i);
                new DataView(header.buffer).setUint32(8, 512, true); 

                const pecBlock = new Uint8Array(532 + 2268 + 2 + stitchBytes.length);
                const label = "PES MERGE";
                for(let i=0; i<label.length; i++) pecBlock[i] = label.charCodeAt(i);
                
                pecBlock[48] = 0; 
                const stitchOffset = 532 + 2268 + 1; 
                pecBlock[stitchOffset-1] = 0; 
                pecBlock.set(stitchBytes, stitchOffset);

                const final = new Uint8Array(header.length + pecBlock.length);
                final.set(header);
                final.set(pecBlock, 512);
                return final;
            }
        };

        // --- UTILS: FONT MANAGER ---
        const CHAR_MAP = {
            'A': 'Upper_A', 'B': 'Upper_B', 'C': 'Upper_C', 'D': 'Upper_D',
            'E': 'Upper_E', 'F': 'Upper_F', 'G': 'Upper_G', 'H': 'Upper_H',
            'I': 'Upper_I', 'J': 'Upper_J', 'K': 'Upper_K', 'L': 'Upper_L',
            'M': 'Upper_M', 'N': 'Upper_N', 'O': 'Upper_O', 'P': 'Upper_P',
            'Q': 'Upper_Q', 'R': 'Upper_R', 'S': 'Upper_S', 'T': 'Upper_T',
            'U': 'Upper_U', 'V': 'Upper_V', 'W': 'Upper_W', 'X': 'Upper_X',
            'Y': 'Upper_Y', 'Z': 'Upper_Z',
            'a': 'Lower_a', 'b': 'Lower_b', 'c': 'Lower_c', 'd': 'Lower_d',
            'e': 'Lower_e', 'f': 'Lower_f', 'g': 'Lower_g', 'h': 'Lower_h',
            'i': 'Lower_i', 'j': 'Lower_j', 'k': 'Lower_k', 'l': 'Lower_l',
            'm': 'Lower_m', 'n': 'Lower_n', 'o': 'Lower_o', 'p': 'Lower_p',
            'q': 'Lower_q', 'r': 'Lower_r', 's': 'Lower_s', 't': 'Lower_t',
            'u': 'Lower_u', 'v': 'Lower_v', 'w': 'Lower_w', 'x': 'Lower_x',
            'y': 'Lower_y', 'z': 'Lower_z',
            '0': '0', '1': '1', '2': '2', '3': '3', '4': '4',
            '5': '5', '6': '6', '7': '7', '8': '8', '9': '9',
            '&': 'Ampersand', '@': 'At', '-': 'Dash', '$': 'Dollar_Sign',
            '!': 'Exclamation', '?': 'Question_Mark', '.': 'Period',
            ',': 'Comma', "'": 'Apostrophe', '#': 'Pound', '%': 'Percent',
            '+': 'Plus', '=': 'Equals', '/': 'Slash',
            '(': 'Left_Paren', ')': 'Right_Paren', ':': 'Colon', ';': 'Semicolon',
            '"': 'Quote', '*': 'Asterisk', '_': 'Underscore', ' ': ' '
        };

        async function scanZipForFonts(file) {
            const fonts = {};
            const zip = new JSZip();
            try {
                const content = await zip.loadAsync(file);
                const promises = [];
                content.forEach((path, entry) => {
                    if (entry.dir || !path.toLowerCase().endsWith('.pes')) return;
                    promises.push((async () => {
                        const parts = path.split('/');
                        let fontName = 'Unknown';
                        // Heuristic to find font name folder
                        for(let i=0; i<parts.length; i++) {
                            if(parts[i].toUpperCase() === 'PES' && i > 0) fontName = parts[i-1];
                        }
                        if(fontName === 'Unknown' && parts.length > 1) fontName = parts[parts.length-2];
                        if(fontName === 'Unknown' && parts.length === 1) fontName = "Root"; 
                        
                        fontName = fontName.replace(/_/g, ' ').trim();
                        if(!fonts[fontName]) fonts[fontName] = [];
                        
                        fonts[fontName].push({
                            name: entry.name.split('/').pop(),
                            blob: await entry.async('blob')
                        });
                    })());
                });
                await Promise.all(promises);
                return fonts;
            } catch(e) { throw e; }
        }

        function findPesFile(fontFiles, char, size) {
            const map = CHAR_MAP[char];
            if (!map) return null;
            const sizeStr = `${size}_Inch`;
            const p1 = `${map}_${sizeStr}`.toLowerCase();
            const p2 = `${map.replace('_',' ')} ${size} Inch`.toLowerCase();
            
            return fontFiles.find(f => {
                const n = f.name.toLowerCase().replace(/ /g, '_');
                const n2 = f.name.toLowerCase();
                return n.includes(p1) || n2.includes(p2);
            });
        }

        // --- COMPONENTS ---
        const Button = ({ onClick, children, variant = 'primary', disabled, className = '' }) => {
            const variants = {
                primary: "bg-indigo-600 text-white hover:bg-indigo-700 disabled:bg-indigo-300",
                secondary: "bg-slate-200 text-slate-700 hover:bg-slate-300 disabled:bg-slate-100",
                danger: "bg-red-50 text-red-600 hover:bg-red-100 disabled:bg-gray-100",
                success: "bg-emerald-600 text-white hover:bg-emerald-700 disabled:bg-emerald-300"
            };
            return (
                <button onClick={onClick} disabled={disabled} className={`px-4 py-2 rounded font-medium flex items-center justify-center gap-2 transition-all ${variants[variant]} ${className}`}>
                    {children}
                </button>
            );
        };

        const App = () => {
            const [fonts, setFonts] = useState({});
            const [loading, setLoading] = useState(false);
            const [loadingMsg, setLoadingMsg] = useState('');
            const [error, setError] = useState('');
            const [dragActive, setDragActive] = useState(false);
            
            const [queue, setQueue] = useState([]);
            const [input, setInput] = useState('');
            const [selFont, setSelFont] = useState('');
            const [size, setSize] = useState(1);
            const [hoop, setHoop] = useState('4x4');
            const [spacing, setSpacing] = useState(10);
            
            const fileInputRef = useRef(null);

            // Startup: Check for cached fonts
            useEffect(() => {
                const loadCached = async () => {
                    setLoading(true);
                    setLoadingMsg('Restoring Library...');
                    try {
                        const cached = await dbApi.getAllFonts();
                        if (cached) {
                            setFonts(cached);
                            setSelFont(Object.keys(cached).sort()[0]);
                        }
                    } catch (e) {
                        console.error("Cache load error", e);
                    } finally {
                        setLoading(false);
                        setLoadingMsg('');
                    }
                };
                loadCached();
            }, []);

            const handleFile = async (file) => {
                if(!file) return;
                setLoading(true); setError('');
                setLoadingMsg('Analyzing Zip File...');
                try {
                    const loaded = await scanZipForFonts(file);
                    if(Object.keys(loaded).length === 0) throw new Error("No PES files found.");
                    
                    setLoadingMsg('Installing to Browser Storage...');
                    const count = await dbApi.saveFonts(loaded);
                    
                    // Merge with existing
                    const merged = { ...fonts, ...loaded };
                    setFonts(merged);
                    if(!selFont) setSelFont(Object.keys(loaded).sort()[0]);
                } catch(e) {
                    setError("Failed to load fonts. Make sure it's a valid ZIP.");
                } finally {
                    setLoading(false);
                    setLoadingMsg('');
                }
            };

            const clearLibrary = async () => {
                if(confirm("Are you sure you want to delete all saved fonts?")) {
                    setLoading(true);
                    await dbApi.clear();
                    setFonts({});
                    setSelFont('');
                    setLoading(false);
                }
            };

            const handleDrop = (e) => {
                e.preventDefault(); e.stopPropagation();
                setDragActive(false);
                if(e.dataTransfer.files && e.dataTransfer.files[0]) {
                    handleFile(e.dataTransfer.files[0]);
                }
            };

            const generate = async () => {
                setLoading(true);
                setLoadingMsg('Generating Stitch Files...');
                // Small delay to let UI render loading state
                await new Promise(r => setTimeout(r, 100));

                try {
                    for(const item of queue) {
                        const fontFiles = fonts[item.font];
                        if(!fontFiles) continue;

                        let totalWidth = 0;
                        const charData = [];
                        
                        // 1. Load Chars
                        for(const char of item.text) {
                           if(char === ' ') {
                               charData.push({ type: 'space' }); continue;
                           }
                           const f = findPesFile(fontFiles, char, item.size);
                           if(f) {
                               const buf = await f.blob.arrayBuffer();
                               const pat = PesParser.decode(new Uint8Array(buf));
                               charData.push({ type: 'char', pat });
                           }
                        }

                        // 2. Metrics
                        const valid = charData.filter(c => c.type === 'char');
                        if(valid.length === 0) continue;
                        const avgW = valid.reduce((acc, c) => acc + c.pat.width, 0) / valid.length;
                        const gap = avgW * (item.spacing / 100);
                        const spaceW = avgW * 0.5;

                        let cursor = 0;
                        const placements = [];
                        charData.forEach(c => {
                            if(c.type === 'space') { cursor += spaceW + gap; }
                            else {
                                placements.push({ pat: c.pat, x: cursor });
                                cursor += c.pat.width + gap;
                            }
                        });
                        const fullWidth = cursor - gap;

                        // 3. Scale to Hoop (Units: 0.1mm)
                        const hoopW = item.hoop === '5x7' ? 1300 : 1000;
                        const scale = fullWidth > (hoopW * 0.9) ? (hoopW * 0.9) / fullWidth : 1;

                        // 4. Merge
                        const mergedStitches = [];
                        const startX = -(fullWidth * scale) / 2;

                        placements.forEach(p => {
                            const offsetX = startX + (p.x * scale);
                            const offsetY = -((p.pat.maxY + p.pat.minY)/2) * scale;
                            p.pat.stitches.forEach(s => {
                                if(s.flags & END) return;
                                mergedStitches.push({
                                    x: (s.x * scale) + offsetX,
                                    y: (s.y * scale) + offsetY,
                                    flags: s.flags
                                });
                            });
                        });
                        if(mergedStitches.length) mergedStitches.push({x:0, y:0, flags: END});

                        // 5. Save
                        const bin = PesParser.encode({ stitches: mergedStitches });
                        const blob = new Blob([bin], {type: "application/octet-stream"});
                        saveAs(blob, `${item.text.replace(/\W/g,'_')}_${item.font}.pes`);
                    }
                } catch(e) {
                    console.error(e);
                    setError("Error generating files");
                }
                setLoading(false);
                setLoadingMsg('');
            };

            return (
                <div className="min-h-screen p-4 md:p-8 max-w-4xl mx-auto space-y-6">
                    <header className="text-center">
                        <div className="inline-flex p-3 bg-indigo-100 rounded-full mb-2 text-indigo-600">
                            <Scissors size={32} />
                        </div>
                        <h1 className="text-3xl font-bold mb-2">Embroidery Word Builder</h1>
                        <p className="text-slate-500">Portable Version with Library Storage</p>
                    </header>

                    <div className="grid md:grid-cols-2 gap-6">
                        {/* LEFT: Config */}
                        <div className="space-y-6">
                            <div 
                                className={`bg-white p-6 rounded-lg border-2 border-dashed transition-colors text-center cursor-pointer relative ${dragActive ? 'drag-active' : 'border-slate-300 hover:bg-slate-50'}`}
                                onDragEnter={() => setDragActive(true)}
                                onDragLeave={() => setDragActive(false)}
                                onDragOver={e => e.preventDefault()}
                                onDrop={handleDrop}
                                onClick={() => !loading && fileInputRef.current?.click()}
                            >
                                <input type="file" ref={fileInputRef} onChange={e => handleFile(e.target.files[0])} accept=".zip" className="hidden" />
                                {loading ? (
                                    <div className="py-2">
                                        <Loader2 className="animate-spin mx-auto text-indigo-600 mb-2" />
                                        <p className="text-sm font-medium text-indigo-600">{loadingMsg || 'Processing...'}</p>
                                    </div>
                                ) : (
                                    <>
                                        <FolderOpen className="mx-auto text-slate-400 mb-2" size={32} />
                                        <p className="font-medium text-slate-700">Drop Font Pack (.zip)</p>
                                        <p className="text-xs text-slate-400 mt-1">Supports Google Drive exports</p>
                                    </>
                                )}
                                {Object.keys(fonts).length > 0 && !loading && (
                                    <div className="mt-4 flex flex-col items-center gap-2">
                                        <div className="inline-flex items-center gap-2 text-xs font-bold text-green-600 bg-green-50 px-3 py-1 rounded-full">
                                            <Database size={12}/> {Object.keys(fonts).length} Fonts Installed
                                        </div>
                                        <button onClick={(e) => { e.stopPropagation(); clearLibrary(); }} className="text-xs text-red-400 hover:text-red-600 underline">
                                            Clear Library
                                        </button>
                                    </div>
                                )}
                            </div>
                            
                            {error && <div className="p-3 bg-red-50 text-red-600 text-sm rounded">{error}</div>}

                            <div className="bg-white p-4 rounded-lg border shadow-sm space-y-4">
                                <div>
                                    <label className="text-xs font-bold text-slate-500 uppercase">Text</label>
                                    <input type="text" value={input} onChange={e => setInput(e.target.value)} className="w-full border rounded p-2 mt-1" placeholder="Enter word..." />
                                </div>
                                <div>
                                    <label className="text-xs font-bold text-slate-500 uppercase">Font</label>
                                    <select value={selFont} onChange={e => setSelFont(e.target.value)} disabled={Object.keys(fonts).length === 0} className="w-full border rounded p-2 mt-1">
                                        {Object.keys(fonts).length === 0 && <option>No fonts loaded</option>}
                                        {Object.keys(fonts).map(f => <option key={f} value={f}>{f}</option>)}
                                    </select>
                                </div>
                                <div className="grid grid-cols-2 gap-2">
                                    <div>
                                        <label className="text-xs font-bold text-slate-500 uppercase">Size</label>
                                        <select value={size} onChange={e => setSize(Number(e.target.value))} className="w-full border rounded p-2 mt-1">
                                            <option value="1">1 Inch</option>
                                            <option value="2">2 Inch</option>
                                            <option value="3">3 Inch</option>
                                        </select>
                                    </div>
                                    <div>
                                        <label className="text-xs font-bold text-slate-500 uppercase">Hoop</label>
                                        <select value={hoop} onChange={e => setHoop(e.target.value)} className="w-full border rounded p-2 mt-1">
                                            <option value="4x4">4x4"</option>
                                            <option value="5x7">5x7"</option>
                                        </select>
                                    </div>
                                </div>
                                <div>
                                    <label className="text-xs font-bold text-slate-500 uppercase">Spacing: {spacing}%</label>
                                    <input type="range" value={spacing} onChange={e => setSpacing(Number(e.target.value))} min="0" max="50" className="w-full mt-2 accent-indigo-600" />
                                </div>
                                <Button onClick={() => {
                                    if(input) {
                                        setQueue([...queue, {id: Date.now(), text: input, font: selFont, size, hoop, spacing}]);
                                        setInput('');
                                    }
                                }} disabled={!input || !Object.keys(fonts).length} className="w-full">
                                    <Plus size={18} /> Add to Queue
                                </Button>
                            </div>
                        </div>

                        {/* RIGHT: Queue */}
                        <div className="bg-white rounded-lg border shadow-sm flex flex-col h-[500px]">
                            <div className="p-4 border-b font-bold bg-slate-50 text-slate-600">Production Queue</div>
                            <div className="flex-1 overflow-y-auto p-4 space-y-2">
                                {queue.length === 0 && (
                                    <div className="h-full flex flex-col items-center justify-center text-slate-400 opacity-50">
                                        <Scissors size={48} className="mb-2" />
                                        <p>Queue is empty</p>
                                    </div>
                                )}
                                {queue.map(q => (
                                    <div key={q.id} className="flex justify-between items-center p-3 border rounded bg-slate-50">
                                        <div>
                                            <div className="font-bold">{q.text}</div>
                                            <div className="text-xs text-slate-500">{q.font} â€¢ {q.size}"</div>
                                        </div>
                                        <button onClick={() => setQueue(queue.filter(i => i.id !== q.id))} className="text-slate-400 hover:text-red-500"><Trash2 size={16}/></button>
                                    </div>
                                ))}
                            </div>
                            <div className="p-4 border-t bg-slate-50">
                                <Button variant="success" className="w-full h-12 text-lg" disabled={queue.length === 0 || loading} onClick={generate}>
                                    {loading ? <Loader2 className="animate-spin" /> : <><Download /> Download All</>}
                                </Button>
                            </div>
                        </div>
                    </div>
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
